
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Posts on katmatt blogs</title>
   <link>http://katmatt.github.io/posts/</link>
   <description>Recent content in Posts on katmatt blogs</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <lastBuildDate>Wed, 15 Jul 2020 15:35:10 +0200</lastBuildDate>
   
       <atom:link href="http://katmatt.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>GraalVM/native-image cross-compilation with github Actions</title>
       <link>http://katmatt.github.io/posts/graalvm-cross-compile-gh-actions/</link>
       <pubDate>Wed, 15 Jul 2020 15:35:10 +0200</pubDate>
       
       <guid>http://katmatt.github.io/posts/graalvm-cross-compile-gh-actions/</guid>
       <description>

&lt;p&gt;GraalVM (&lt;a href=&#34;https://www.graalvm.org/&#34;&gt;https://www.graalvm.org/&lt;/a&gt;) allows to compile Java programs into native code with the &lt;code&gt;native-image&lt;/code&gt; executable. This gives Java developers new options, because you can now release native executable for your users. And that brings Java to the world of easy to install command-line tools, which at the moment is one of the unique selling points of newer programming languages like Go or Rust. Both of these languages have dedicated support for cross-compiling programs/libraries to target architectures different from the host system.&lt;/p&gt;

&lt;p&gt;But one limitation of &lt;code&gt;native-image&lt;/code&gt; is that it doesn&amp;rsquo;t support cross-compilation out of the box (see open issue: &lt;a href=&#34;https://github.com/oracle/graal/issues/407&#34;&gt;native-image: Cross compilation support?&lt;/a&gt;). That means that you have to run &lt;code&gt;native-image&lt;/code&gt; on all platforms that your Java program should support.&lt;/p&gt;

&lt;p&gt;This article will show you how you can use github actions to simplify this task by automating it. Then the only thing you have to do to trigger the release of native excutables of your program is to tag your release and push that tag to github.&lt;/p&gt;

&lt;h2 id=&#34;setup-your-gradle-build&#34;&gt;Setup your gradle build&lt;/h2&gt;

&lt;p&gt;In this article,  we will use the popular &lt;a href=&#34;https://gradle.org/&#34;&gt;gradle&lt;/a&gt; build tool together with the &lt;a href=&#34;https://github.com/palantir/gradle-graal&#34;&gt;Palantir GraalVM gradle plugin&lt;/a&gt;. This setup will download the GraalVM toolchain, cache it locally and thus makes it very easy to use. This plugin is available from the gradle plugin and central and this makes it very easy to integrate it into our &lt;code&gt;gradle.build&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;plugins {
    id &#39;com.palantir.graal&#39; version &#39;0.7.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can add the following entries to your modules &lt;code&gt;build.gradle&lt;/code&gt; to configure the &lt;code&gt;nativeImage&lt;/code&gt; gradle task:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;apply plugin: &#39;com.palantir.graal&#39;

graal {
    graalVersion &#39;20.0.0&#39;
    outputName &#39;cross-compile-demo&#39;
    mainClass &#39;com.maschinenstuermer.crosscompile.demo.App&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-your-first-native-executable&#34;&gt;Build your first native executable&lt;/h2&gt;

&lt;p&gt;After this setup, building your first native executable is as simple as running &lt;code&gt;./gradlew nativeImage&lt;/code&gt;. This will download the graal toolchain to your computer, execute the &lt;code&gt;native-image&lt;/code&gt; compiler and then generate the executable to &lt;code&gt;/build/graal/cross-compile-demo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Running this executable then outputs the classical:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello world.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is to archive the executable into a zip file, which we later will upload to the github release. We do this by adding the following task to our &lt;code&gt;build.gradle&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;task zipExecutable(type: Zip) {
    dependsOn &#39;nativeImage&#39;
    
    archiveFileName = &amp;quot;cross-compile-demo.zip&amp;quot;
    destinationDirectory = file(&amp;quot;$buildDir/dist&amp;quot;)

    from &amp;quot;$buildDir/graal&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this additional task, we can now build and archive our executable by running &lt;code&gt;./gradlew zipExecutable&lt;/code&gt;. This produces our zip file in the &lt;code&gt;build/dist&lt;/code&gt; folder. You can see the full build file here: &lt;a href=&#34;https://github.com/katmatt/cross-compile-gh-actions/blob/master/build.gradle&#34;&gt;build.gradle&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cross-compiling-with-github-actions&#34;&gt;Cross-compiling with Github Actions&lt;/h2&gt;

&lt;p&gt;Our release process is triggered when a user tags a release and pushes these tags to github. This is accomplished with the following trigger in our workflow file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;on:
  push:
    tags:
    - &#39;v*&#39; # Push events to matching v*, i.e. v1.0, v20.15.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our workflow then creates a github release for this tag with the following job definition and stores the &lt;code&gt;upload_url&lt;/code&gt; as an output that our downstream jobs can use to upload their artifacts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v2
      - name: Create Release
        id: create-release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now add jobs for each supported operating system, which depends on our &lt;code&gt;create-release&lt;/code&gt; job by setting the &lt;code&gt;needs:&lt;/code&gt; facet to &lt;code&gt;create-release&lt;/code&gt;. The following workflow defines the release build for linux:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  perform-release-linux:
    needs: create-release
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 1.8
      uses: actions/setup-java@v1
      with:
        java-version: 1.8
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    - name: Build native image with Gradle
      run: ./gradlew zipExecutable
    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ needs.create-release.outputs.upload_url }}  
        asset_path: ./build/dist/cross-compile-demo.zip
        asset_name: cross-compile-demo_linux_amd64.zip
        asset_content_type: application/zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this job references the &lt;code&gt;upload_url&lt;/code&gt; output from our &lt;code&gt;create-release&lt;/code&gt; job with the &lt;code&gt;${{ needs.create-release.outputs.upload_url }}&lt;/code&gt; expression.
You can see the full workflow file here: &lt;a href=&#34;https://github.com/katmatt/cross-compile-gh-actions/blob/master/.github/workflows/perform-release.yml&#34;&gt;perform-release.yml&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This article showed you how you can leverage github actions to cross-compile your Java program for different target architectures. The presented solution works with an easy setup. But it has a drawback too: Our workflow downloads the GraalVM distribution for each platform on each release. And releasing our simple demo program took already 5 minutes.&lt;/p&gt;

&lt;p&gt;But if you compare this solution with running the cross-compilation manually - across several computers or virtual machines - and if your release frequency is daily or weekly, then this article provides a good enough solution. And our proposed solution could be further simplified by using matrix builds or by cahing the downloaded GraalVM distribution, so feel free to improve this solution further!&lt;/p&gt;

&lt;p&gt;You can find the source code for this article here: &lt;a href=&#34;https://github.com/katmatt/cross-compile-gh-actions&#34;&gt;https://github.com/katmatt/cross-compile-gh-actions&lt;/a&gt;&lt;/p&gt;
</description>
     </item>
   
 </channel>
</rss>
